<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-mini-service.html">mini-service</a><ul class='methods'><li data-type='method'><a href="module-mini-service.html#.getClient">getClient</a></li><li data-type='method'><a href="module-mini-service.html#.startServer">startServer</a></li></ul></li><li><a href="module-server.html">server</a><ul class='methods'><li data-type='method'><a href="module-server.html#~startServer">startServer</a></li></ul></li></ul>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><h1>Mini-service</h1><p>Simplistic µService skeleton</p>
<p><a href="https://npmjs.org/package/mini-service"><img src="https://img.shields.io/npm/v/mini-service.svg" alt="npm package"></a>
<a href="https://david-dm.org/feugy/mini-service"><img src="https://img.shields.io/david/feugy/mini-service.svg" alt="dependencies"></a>
<a href="https://travis-ci.org/feugy/mini-service"><img src="https://api.travis-ci.org/feugy/mini-service.svg" alt="build"></a>
<a href="https://coveralls.io/r/feugy/mini-service?branch=master"><img src="https://img.shields.io/coveralls/feugy/mini-service/master.svg" alt="coverage"></a></p>
<h2>Introduction</h2><p>The goal of mini-service is to give the minimal structure to implement a µService, that can be invoked locally or remotely.</p>
<p>Its principles are the following:</p>
<ul>
<li>very easy to add new service api endpoints</li>
<li>easy to use client interface, same usage both locally and remotely</li>
<li>hide deployment details and provide simple-yet-working solution</li>
<li>promises based (and thus, async/await compatible)</li>
</ul>
<p>mini-service uses the latest ES6 features, so it requires node 6+</p>
<h2>Example</h2><p>Here is a simple calculator service definition, that exposes functions to add and subtract numbers.</p>
<p><code>calc-service.js</code></p>
<pre class="prettyprint source lang-javascript"><code>module.exports = {
  name: 'calc-service',
  version: '1.0.0',
  init: () => {
    // each exposed APIs could also return a promise/be async
    add: (a, b) => a + b,
    subtract: (a, b) => a - b
  }
}</code></pre><p>If you want to use it locally in a different file:
require the service definition, and create a [mini-client][mini-client-url] with it</p>
<p><code>caller-local.js</code></p>
<pre class="prettyprint source lang-javascript"><code>const {getClient} = require('mini-service')
const calcService = require('./calc-service')

const calc = getClient(calcService)</code></pre><p>Then, init it (it's an async operation) and invoke any exposed API you need:</p>
<p><code>caller-local.js</code></p>
<pre class="prettyprint source lang-javascript"><code>await calc.init()
const sum = await calc.add(10, 5)
console.log(`Result is: ${sum}`)</code></pre><p>Now let's imagine you need to deploy your calculator service in a standalone Http server, and invoke it from a remote server.
To turn your local service into a real server, expose your service definition with mini-service's <code>startServer()</code>:</p>
<p><code>calc-service.js</code></p>
<pre class="prettyprint source lang-javascript"><code>const {startServer} = require('mini-service')

module.exports = {...} // same service definition as above
// starts Http server
startServer(module.exports)</code></pre><p>A server is now listening on port 3000.</p>
<p>And to use it from a remote caller, creates a mini-client giving the proper url:</p>
<p><code>caller-remote.js</code></p>
<pre class="prettyprint source lang-javascript"><code>const getClient = require('mini-client') // or: const {getClient} = require('mini-service')

const calc = getClient({
  remote: 'http://localhost:3000'
})</code></pre><p>Please note that you <strong>don't need to require the service definition anymore</strong>.</p>
<p>Usage is exactly the same as previously.</p>
<p><code>caller-remote.js</code></p>
<pre class="prettyprint source lang-javascript"><code>await calc.init() // no-op, can be skipped
const sum = await calc.add(10, 5)
console.log(`Result is: ${sum}`)</code></pre><h2>Going further</h2><p>Please also checkout:</p>
<ul>
<li><a href="https://feugy.github.io/mini-service/">API Reference</a></li>
<li><a href="https://github.com/feugy/mini-service/tree/master/FAQ.md">Frequently asked questions</a></li>
<li>[Examples][examples]</li>
</ul>
<p>FAQ covers topics like modularity, aynsc initialization, parameters validation...</p>
<h2>Acknowledgements</h2><p>This project was kindly sponsored by <a href="http://nearform.com">nearForm</a>.</p>
<h2>License</h2><p>Copyright <a href="https://github.com/feugy">Damien Simonin Feugas</a> and other contributors, licensed under <a href="./LICENSE">MIT</a>.</p>
<h2>2.x to 3.x changes</h2><p>Groups are now used as sub-objects of mini-client.</p>
<p>Given a service exposing:</p>
<ul>
<li>api <code>ping</code> without group <em>(or if group has same name as overall service)</em></li>
<li>group <code>a</code> with apis <code>ping</code> &amp; <code>pong</code></li>
<li>group <code>b</code> with api <code>ping</code></li>
</ul>
<p>the final Mini-client will be:</p>
<pre class="prettyprint source lang-javascript"><code>client = {
  ping(),
  a: {
    ping(),
    pong()
  },
  b: {
    ping()
  }
}</code></pre><h2>1.x to 2.x changes</h2><p>Local services, as remote services, <strong>must</strong> have <code>name</code> and <code>version</code> options defined</p>
<p>When loading services, the <code>services</code> property was renamed to <code>groups</code>, and <code>serviceOpts</code> is now <code>groupOpts</code>:</p>
<pre class="prettyprint source lang-javascript"><code>const {startServer} = require('mini-service')

startServer({
  groups: [ // was services previously
    require('../serviceA'),
    require('../serviceB'),
    require('../serviceC')
  ],
  groupOpts: { // was serviceOpts previously
    serviceA: {},
    serviceB: {},
    serviceC: {}
  }
})</code></pre><h2>Changelog</h2><h3>3.3.0</h3><ul>
<li>expose customizable OpenAPI descriptor</li>
<li>allow default values for API parameters</li>
</ul>
<h3>3.2.1</h3><ul>
<li>disabled low-level socket timeout</li>
</ul>
<h3>3.2.0</h3><ul>
<li>Support synchronous <code>init()</code> and API functions</li>
<li>Dependencies update</li>
</ul>
<h3>3.1.0</h3><ul>
<li>Don't wrap Boom errors to keep http status codes</li>
<li>Use <a href="https://standardjs.com/">standard.js</a> lint configuration</li>
</ul>
<h3>3.0.0</h3><ul>
<li>[<em>Breaking change</em>] Use mini-client@3.0.0 that uses sub-objects for exposed groups.</li>
<li>Returns CRC32 checksum of exposed API during every call, to allow mini-client checking compatibility</li>
<li>Dependency update (except Joi 11 that introduced a regression in Hapi)</li>
</ul>
<h3>2.1.0</h3><h3>2.0.0</h3><ul>
<li>Externalized client using [mini-client][mini-client-url], to decouple clients and service code</li>
<li>[<em>Breaking change</em>] Introduce new terminology, with service descriptor and API groups</li>
<li>[<em>Breaking change</em>] When parsing exposed APIs, expect 'group' property instead of 'name'</li>
<li>Allow to declare API without groups</li>
<li>Allow to declare API validation in group options</li>
<li>[<em>Breaking change</em>] Force name+version on local client</li>
<li>Better documentation and code examples</li>
<li>More understandable error messages</li>
</ul>
<h3>1.3.0</h3><ul>
<li>Add NSP checks, and upgrade vulnerable dependency</li>
</ul>
<h3>1.2.2</h3><ul>
<li>fix parameter detection</li>
<li>fix Proxy that is detected as a Thenable object</li>
</ul>
<h3>1.2.1</h3><ul>
<li>fix issue related to parameter name extraction when using arrow functions</li>
</ul>
<h3>1.2.0</h3><ul>
<li>use proxy to delay remotely exposed Apis retrieval to the first effective usage</li>
<li>activate Travis CI and coveralls reports</li>
<li>update dependencies</li>
</ul>
<h3>1.1.3</h3><ul>
<li>client functions always returns a real promise (request-promise return a mixed stream + promise object that prevent direct usage in Hapi)</li>
<li>checks exposed services interface to avoid mistakes</li>
</ul>
<h3>1.1.2</h3><ul>
<li>update dependencies</li>
<li>use lab configuration file</li>
</ul>
<h3>1.1.1</h3><ul>
<li>fix bug that prevent to specify version when creating the service</li>
</ul>
<h3>1.1.0</h3><ul>
<li>allows to use general logger object within exposed services</li>
</ul>
<h3>1.0.0</h3><ul>
<li>initial release</li>
</ul></article>
    </section>






</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>